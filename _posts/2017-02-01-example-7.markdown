---
layout: post
title:  "Jekyll 开发文档"
description: Show you how to developer a web static site by Jekyll. 
date:   2017-02-01 10:51:47 +0530
categories: jekyll update
img: karna.jpg
categories: [one, two]
color: 1976D2
author: liberalman
tags: Jekyll 
---
Karna is one of the central characters in the Hindu epic Mahābhārata. Karna was one of the greatest warriors, whose martial exploits are recorded in the epic, and the only warrior believed to be able to defeat Arjuna in battle.

Karna was the son of Surya(Sun) and Kunti, born to Kunti before her marriage with Pandu.

![Karna]({{site.baseurl}}/images/karna-2.jpg)


Image Credits - [18days](https://www.youtube.com/watch?v=kyHFBybC3RI) and [Nisachar](http://nisachar.deviantart.com/gallery/37429163/18-Days) 


### 搭建本地Jekyll环境
github上搭建了一个自己的静态博客，由于markdown写完后不是立即可见，所以每次写完文章都要经过在线调试，而在线调试就得上线文章，每次上线都得重复git add， git commit， git push这三步，非常的繁琐。我们可以安装jekyll本地环境线下调试ok，再上传到github。
下面就来说说我的安装步骤，我的安装环境是CentOS 7.2 。

1. 安装ruby

```
yum install ruby-devel
```

2. 去掉官方ruby源，改用国内淘宝源，速度快

```
gem sources --remove http://rubygems.org
gem sources -a https://ruby.taobao.org
```

4. 安装jekyll

```
gem install jekyll
```

5. 安装分页、seo优化tag等依赖包

```
gem install jekyll-paginate
gem install jekyll-seo-tag
```

6. 上面步骤执行完后，本地的jekyll环境就搭建完成了，进入你博客的目录，运行下面的命令启动

```
jekyll server
```

之后会有提示，访问http://0.0.0.0:4000就可以啦。
或者要绑定ip的话，运行

```
jekyll serve -w --host=192.168.0.4
```

-w等同于--watch，可以持续监控文件的修改情况

layout使用指定的模版文件，不加扩展名。模版文件放在_layouts目录下。

title文章的标题。

date发布文章的时间。

categories将文章设置成不同的属性。系统在生成页面时会根据多个属性值来生成文章地址。以上设置会生http://.../jekyll/update/...格式的文章链接。

tags标签，一篇文章可以设置多个标签，使用空格分割。

        *layout: post*指的是博文格式安装_layouts文件夹下的post.html指定的格式来显示。 
        *categories: [Tools]*指定博文分类。 
        *tags: [jekyll, github, git, markdown]*指定博文标签。


.Jekyll是支持图片和其它资源文件的，但本人在此强烈建议所有的文件资源全都通过外链的方式解决，毕竟GitHub主要还是用来管理源代码不适合存放资源文件。如果只是需要简单的图床的话直接使用weibo的私人相册的功能即可就是管理起来不太方便。当然其实最好还是使用像某牛云存储之类的云存储服务，访问量不大的话免费账户基本能满足要求了，管理资源文件也很方便（感觉有点做广告的嫌疑-_-!）


### 分页实现

一个博客不可能只有几篇文章，如果所有文章全部放在一个页面中，在文章不多的情况下也许较为直观，一旦文章数量增加，不仅加大了用户需要加载的数据量，也为用户检索文章造成了障碍，所以基本上每个博客都会有文章的分页。一般的分页都是通过像JSP的模板引擎直接在从数据库中分页取出时生成动态生成页面，或者通过ajax从数据库分页取出传递到前端。但现在github+jekyll是静态的页面，没有数据库。好在jekyll支持分页功能

##### 开启分页功能
首先我们需要在jekyll中开启分页功能，在jekyll的_config.yml中加入分页配置：

```
paginate: 5
paginate_path: "page:num"
```

第一行定义了每页的文章数量，而第二行则定义了在分页的结果，比如在/index.html中使用分页，定义为page:num，则第二页的路径将是/page2/index.html，第三页的路径将是/page3/index.html，以此类推

需要注意的几个点：

- 分页只在html文件中起作用
- paginate_path同时定义了需要被分页的文件，本人测试这个叫index.html，具体目录由paginate_path中的路径定义，如果定义的目录没有，则会向上寻找index.html，直到根目录的index.html，具体机制官网上没有详细说，所以还需要进一步实验

##### 使用分页
只是开启了分页还没有用，我们需要确实使用到首页之中，在首页(/index.html)中添加如下代码：

{% highlight ruby %}

{% for post in paginator.posts %}
    <a href="{{ post.url }}">{{ post.title }}</a>
{% endfor %}

{% endhighlight %}

这样，jekyll就会根据paginator来进行分页了，被分出来多少页，就会有多少个页面生成。排1-5的文章就在/index.html中了，而排6-10的文章则在/page2/index.html中，依次类推

##### 换页
只是分页还不够，我们还需要在每个页面上做一个跳转到其他页面的导航，这里需要用到paginator的一些其他属性

首先检测总的页数，如果只有一页，自然就不需要分页了。通过paginator的total_pages属性能判断总页数：

{% highlight ruby %}

{% if paginator.total_pages > 1 %}
<!-- 分页代码 -->
{% endif %}

{% endhighlight %}

我们需要一个跳转到上一页的按钮，这个按钮在第一页不需要显示，通过paginator的previous_page属性来判断是否是第一个页面，使用paginator的previous_page_path来输出上一页的路径，注意在前面添加baseurl，并进行一些必要的字符替换：

{% highlight ruby %}

{% if paginator.previous_page %}
    <a href="{{ paginator.previous_page_path | prepend: site.baseurl | replace: '//', '/' }}"上一页</a>
{% endif %}

{% endhighlight %}

接着是生成所有页面的按钮，并使当前页按钮无效化，遍历所有页面，使用paginator的page属性来确定当前页，如果是当前页，则按钮无效，否则使用{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}来将:num替换成当前页面的数字生成页面路径：

{% highlight ruby %}

{% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      <span class="active">{{ page }}</span>
    {% elsif page == 1 %}
      <a href="{{ '/index.html' | prepend: site.baseurl | replace: '//', '/' }}">{{ page }}</a>
    {% else %}
      <a href="{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}">{{ page }}</a>
    {% endif %}
{% endfor %}

{% endhighlight %}

最后生成一个下一页的按钮，在最后一页不显示，和上一页按钮类似，通过paginator的next_page_path来确定是否还有下一页：

{% highlight ruby %}

{% if paginator.next_page %}
    <a href="{{ paginator.next_page_path | prepend: site.baseurl | replace: '//', '/' }}">下一页</a>
{% endif %}

{% endhighlight %}

这样一个完整的分页导航功能就做好了，效果就和博客主页上的分页效果是一样的

##### 总结
jekyll的分页总的来说还算给力，基本的功能可以完成。但是有一些缺陷，就是category，tag的分类分页无法实现，必须通过插件的方式来做。但是github不允许三方插件，所以只能通过一些其他的方式实现了


### 问题
#### ruby编译scss出现invalid GBK错误
问题描述
在windows7上面，通过ruby编译scss时，发现编译报错，内容如下：

```
Conversion error: Jekyll::Converters::Scss encountered an error while converting 'css/main.scss':
                         Invalid GBK character "\xE3" on line 315
```

虽然给出来了报错的原因，但是尼玛，main.scss总共也没有315行啊，而且并没有中文注释什么的。查找一番之后才发现，这里编译器报错的位置不一定是scss中的位置，也有可能是你在scss中引用了其他库中含有中文字符。我在scss中引入了字体文件，文件中包含了中文字符

解决办法
1.在ruby的安装目录下找到engine.rb文件，目录格式如D:\ruby\Ruby21\lib\ruby\gems\2.1.0\gems\sass-3.4.15\lib\sass在文件中添加一行Encoding.default_external = Encoding.find('utf-8')
在require语句结束处，如：

require 'sass/media'
require 'sass/supports'
module Sass   
Encoding.default_external = Encoding.find('utf-8')

2.在scss文件的头部加一行@charset "utf-8"

#### 如何让jekyll服务可以在局域网中访问
由于jekyll将地址绑定到了127.0.0.1，导致局域网的其它机器并不能访问它的服务。但实际上只要改变运行jekyll的参数就可以了。

```
$ jekyll serve -w --host=0.0.0.0
Server address: http://0.0.0.0:4000/
Server running... press ctrl-c to stop.
```

这样就可以通过该机器的IP地址访问网站了。




### 参考博文
> http://blog.csdn.net/u014015972/article/details/50497254
